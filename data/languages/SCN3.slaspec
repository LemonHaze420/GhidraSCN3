#########################################################################################################
# Scenario Script v3 VM processor module
# 
# 
#########################################################################################################
# Processor Configuration
#########################################################################################################
define endian=little;
define alignment=1;

define space ram        type=ram_space          size=4 wordsize=1 default;
define space register   type=register_space     size=4;

define register offset=0x00 size=4 [ r0 r1 r2 r3 r14 sp ];

define token instr(8)
	OP = (0, 7);
define token immtoken1(8)
        imm8 = (0, 7);
define token immtoken2(16)
        imm16 = (0, 15);
define token immtoken4(32)
        imm32 = (0, 31);

#########################################################################################################
# Macros 
#########################################################################################################    
imm8t:          "#"^imm8         is imm8         { tmp:4 = imm8; export tmp; }
imm16t:         "#"^imm16        is imm16        { tmp:4 = imm16; export tmp; }
imm32t:         "#"^imm32        is imm32        { tmp:4 = imm32; export tmp; }

macro getStackValue(i,v) {
        v = *[register]sp + (4 * i);
}
macro setStackValue(i,v) {
        *[register]sp + (4 * i) = v;
}

macro stackSim_r0(i) {
        if ( i >= 4 ) goto <set>;
        goto <skip>;
        <set>
        r0 = 0;
        <skip>
}
macro stackSim_r1(i) {
        if ( i >= 8 ) goto <set>;
        goto <skip>;
        <set>
        r1 = 0;
        <skip>
}
macro stackSim_r2(i) {
        if ( i >= 12 ) goto <set>;
        goto <skip>;
        <set>
        r2 = 0;
        <skip>
}
macro stackSim_r3(i) {
        if ( i >= 16 ) goto <set>;
        goto <skip>;
        <set>
        r3 = 0;
        <skip>
}

macro push(x){
	sp = sp - 4;
	*:4 sp = x;  
}
macro pop(x){
	x = *:4 sp;
	sp = sp + 4;
}

#########################################################################################################
# Instructions
#########################################################################################################
define pcodeop MOBJ1;
define pcodeop MOBJ2;
define pcodeop MOBJ3;
define pcodeop ShenmueFunc;

:MOBJ1 imm8t             is OP=0x10 ; imm8t {
        MOBJ1(imm8t);
}
:MOBJ2 imm8t             is OP=0x11 ; imm8t {
        MOBJ2(imm8t);
}
:MOBJ3 imm8t             is OP=0x12 ; imm8t {
        MOBJ3(imm8t);
}
:MOBJ1 imm16t            is OP=0x20 ; imm16t {
        MOBJ1(imm16t);
}
:MOBJ2 imm16t            is OP=0x21 ; imm16t {
        MOBJ2(imm16t);
}
:MOBJ3 imm16t            is OP=0x22 ; imm16t {
        MOBJ3(imm16t);
}
:MOBJ1 imm32t            is OP=0x30 ; imm32t {
        MOBJ1(imm32t);
}
:MOBJ2 imm32t            is OP=0x31 ; imm32t {
        MOBJ2(imm32t);
}
:MOBJ3 imm32t            is OP=0x32 ; imm32t {
        MOBJ3(imm32t);
}

#########################################################################################################
# PUSH
#########################################################################################################
# @TODO: Clean these up, we can reduce how many we define by using bitmasks.


# (opcode & 0xc0) == 128 ? opcode & 0x3f == 0			is POP EAX
# (opcode & 0xc0) == 128 ? opcode & 0x3f == 1			is PUSH EAX

:PUSH r14             is OP=0x81 {
       push(r14); 
}
:POP r14             is OP=0x80 {
        pop(r14);
}

:PUSH imm8t             is OP=0x17 ; imm8t {
        local val = imm8t;
        push(val);
}
:PUSH imm16t            is OP=0x27 ; imm16t {
        #r0 = imm16t;
        local val = imm16t;
        push(val);        
}
:PUSH imm32t            is OP=0x37 ; imm32t {
        #r0 = imm32t;
        local val = imm32t;
        push(val);         
}
:PUSH imm8t             is OP=0x50 ; imm8t {
        local val = imm8t;
        push(val);
}
:PUSH imm8t             is OP=0x51 ; imm8t {
        #r0 = imm8t;
        local val = imm8t;
        push(val);
}
:PUSH imm16t            is OP=0x52 ; imm16t {
        local val = imm16t;
        push(val);
}
:PUSH imm32t            is OP=0x53 ; imm32t {
        #r0 = imm32t;
        local val = imm32t;
        push(val); 
}
:PUSH imm8t             is OP=0x5E ; imm8t {
        local val = imm8t;
        push(val);
}
:PUSH imm8t             is OP=0x5C ; imm8t {
        local val = imm8t;
        push(val);
}
:PUSH imm8t             is OP=0x5F ; imm8t {
        local val = imm8t;
        push(val);
}
:PUSH imm16t             is OP=0x60 ; imm16t {
        #r0 = imm16t;
        local val = imm16t;
        push(val); 
}
:PUSH imm8t             is OP=0x61 ; imm8t {
        local val = imm8t;
        push(val);
}
:PUSH imm16t            is OP=0x62 ; imm16t {
        #r0 = imm16t;
        local val = imm16t;
        push(val); 
}
:PUSH imm32t            is OP=0x63 ; imm32t {
        #r0 = imm32t;
        local val = imm32t;
        push(val); 
}
:PUSH imm16t            is OP=0x68 ; imm16t {
        #r0 = imm16t;
        local val = imm16t;
        push(val); 
}
:PUSH imm16t             is OP=0x6A ; imm16t {
        local val = imm16t;
        push(val);
}
:PUSH imm16t             is OP=0x6B ; imm16t {
        local val = imm16t;
        push(val);
}
:PUSH imm32t             is OP=0x70 ; imm32t {
        #r0 = imm32t;
        local val = imm32t;
        push(val); 
}
:PUSH imm8t             is OP=0x71 ; imm8t {
        local val = imm8t;
        push(val);
}
:PUSH imm16t            is OP=0x72 ; imm16t {
        #r0 = imm16t;
        local val = imm16t;
        push(val); 
}
:PUSH imm32t            is OP=0x73 ; imm32t {
        #r0 = imm32t;
        local val = imm32t;
        push(val);      
}

#0x82 	        1000 0010 	[MOBJ] Reads 8-bit value from cycle pointer
:RD8CYCL        is OP=0x82  unimpl

#0x83 	        1000 0011 	[MOBJ] Reads 16-bit value from cycle pointer
:RD16CYCL        is OP=0x83  unimpl

#0x84 	        1000 0100 	[MOBJ] Reads 32-bit value from cycle pointer
:RD32CYCL        is OP=0x84  unimpl

#0x85 	        1000 0101 	[MOBJ] Writes 8-bit to cycle pointer
:WR8CYCL         is OP=0x85  unimpl

#0x86 	        1000 0110 	[MOBJ] Writes 16-bit to cycle pointer
:WR16CYCL        is OP=0x86  unimpl

#0x87 	        1000 0111 	[MOBJ] Writes 32-bit to cycle pointer
:WR32CYCL        is OP=0x87  unimpl

#########################################################################################################
# ADD SP, #X
#########################################################################################################
:ADD "SP, " imm8t             is OP=0x13 ; imm8t {
        sp = sp + imm8t;
        #stackSim_r0(imm8t);
        #stackSim_r1(imm8t);
        #stackSim_r2(imm8t);
        #stackSim_r3(imm8t);
}
:ADD "SP, " imm16t            is OP=0x23 ; imm16t {
        sp = sp + imm16t;
        #stackSim_r0(imm16t);       
        #stackSim_r1(imm16t);       
        #stackSim_r2(imm16t);       
        #stackSim_r3(imm16t);       
}
:ADD "SP, " imm32t            is OP=0x33 ; imm32t {
        sp = sp + imm32t;
        #stackSim_r0(imm32t);        
        #stackSim_r1(imm32t);        
        #stackSim_r2(imm32t);        
        #stackSim_r3(imm32t);        
}

#########################################################################################################
# JMP
#########################################################################################################

# JMP by IMM + other val
:JMP imm8t             is OP=0x14 ; imm8t {
        local dest = imm8t + inst_next;
        goto [dest];
}
:JMP imm16t            is OP=0x24 ; imm16t {
        local dest = imm16t + inst_next;
        goto [dest];
}
:JMP imm32t            is OP=0x34 ; imm32t {
        local dest = imm32t + inst_next;
        goto [dest];
}

# JMP by IMM
:JMP imm8t             is OP=0x15 ; imm8t {
        local dest = imm8t + inst_next;
        goto [dest];
}
:JMP imm16t            is OP=0x25 ; imm16t {
        local dest = imm16t + inst_next;
        goto [dest];
}
:JMP imm32t            is OP=0x35 ; imm32t {
        local dest = imm32t + inst_next;
        goto [dest];
}

# IF R14 is zero, then JMP...
:JZ imm8t             is OP=0x16 ; imm8t {
        local dest = imm8t + inst_next;
        if ( r14 != 0 ) goto <skip>;
        goto [dest];
        <skip>
}
:JZ imm16t            is OP=0x26 ; imm16t {
        local dest = imm16t + inst_next;
        if ( r14 != 0 ) goto <skip>;
        goto [dest];
        <skip>
}
:JZ imm32t            is OP=0x36 ; imm32t {
        local dest = imm32t + inst_next;
        if ( r14 != 0 ) goto <skip>;
        goto [dest];
        <skip>
}

#########################################################################################################
# CALL
#########################################################################################################

:CALL imm8t             is OP=0x19 ; imm8t unimpl
:CALL imm16t            is OP=0x29 ; imm16t unimpl
:CALL imm32t            is OP=0x39 ; imm32t unimpl

:CALL imm8t             is OP=0x1A ; imm8t unimpl
:CALL imm16t            is OP=0x2A ; imm16t unimpl
:CALL imm32t            is OP=0x3A ; imm32t unimpl

# Shenmue Fn Table
:CALL_SSF imm8t             is OP=0x1B ; imm8t {
        local val1:4 = *:4 sp;
        local val2:4 = *:4 (sp + 4);
        local val3:4 = *:4 (sp + 8);
        local val4:4 = *:4 (sp + 12);

        ShenmueFunc(imm8t, val1, val2, val3, val4);
}
:CALL_SSF imm16t            is OP=0x2B ; imm16t {
        local val1:4 = *:4 sp;
        local val2:4 = *:4 (sp + 4);
        local val3:4 = *:4 (sp + 8);
        local val4:4 = *:4 (sp + 12);

        ShenmueFunc(imm16t, val1, val2, val3, val4);
        # ShenmueFunc(imm16t, r0, r1, r2, r3);
}
:CALL_SSF imm32t            is OP=0x3B ; imm32t {
        local val1:4 = *:4 sp;
        local val2:4 = *:4 (sp + 4);
        local val3:4 = *:4 (sp + 8);
        local val4:4 = *:4 (sp + 12);

        ShenmueFunc(imm32t, val1, val2, val3, val4);
        # ShenmueFunc(imm32t, r0, r1, r2, r3);
}

define pcodeop CallTblFn0;

:CALL imm8t             is OP=0x1C ; imm8t {
        local val1:4 = *:4 sp;
        local val2:4 = *:4 (sp + 4);
        local val3:4 = *:4 (sp + 8);
        local val4:4 = *:4 (sp + 12);

        CallTblFn0(imm8t, val1, val2, val3, val4);
}
:CALL imm16t            is OP=0x2C ; imm16t {
        local val1:4 = *:4 sp;
        local val2:4 = *:4 (sp + 4);
        local val3:4 = *:4 (sp + 8);
        local val4:4 = *:4 (sp + 12);

        CallTblFn0(imm16t, val1, val2, val3, val4);
}
:CALL imm32t            is OP=0x3C ; imm32t {
        local val1:4 = *:4 sp;
        local val2:4 = *:4 (sp + 4);
        local val3:4 = *:4 (sp + 8);
        local val4:4 = *:4 (sp + 12);

        CallTblFn0(imm32t, val1, val2, val3, val4);
}

:CALL imm8t             is OP=0x1D ; imm8t {
        local val1:4 = *:4 sp;
        local val2:4 = *:4 (sp + 4);
        local val3:4 = *:4 (sp + 8);
        local val4:4 = *:4 (sp + 12);

        CallTblFn0(imm8t, val1, val2, val3, val4);
}
:CALL imm16t            is OP=0x2D ; imm16t {
        local val1:4 = *:4 sp;
        local val2:4 = *:4 (sp + 4);
        local val3:4 = *:4 (sp + 8);
        local val4:4 = *:4 (sp + 12);

        CallTblFn0(imm16t, val1, val2, val3, val4);
}
:CALL imm32t            is OP=0x3D ; imm32t {
        local val1:4 = *:4 sp;
        local val2:4 = *:4 (sp + 4);
        local val3:4 = *:4 (sp + 8);
        local val4:4 = *:4 (sp + 12);

        CallTblFn0(imm32t, val1, val2, val3, val4);
}

# Invalid Opcode
:RET            is OP=0x00 {
        tmp:4 = 0;
        return [tmp];
}

#########################################################################################################
# Operators
#########################################################################################################

:NEG "r0"           is OP=0x8E {
        r0 = ~r0;
}
:AND "r1, r0"       is OP=0x8F  {
        r1 = r1 & r0;
}
:OR  "r1, r0"       is OP=0x90  {
        r1 = r1 | r0;
}
:XOR "r1, r0"        is OP=0x91  {
        r1 = r1 ^ r0;
}
:ADD "r1, r0"         is OP=0x92  {
        r1 = r1 + r0;
}
:SUB "r1, r0"        is OP=0x93  {
        r1 = r1 - r0;
}
:MUL "r1, r0"        is OP=0x94  {
        r1 = r1 * r0;
}
:DIV "r1, r0"        is OP=0x95  {
        r1 = r1 / r0;
}
:MOD "r1, r0"        is OP=0x96  {
        r1 = r1 % r0;
}
:LSHIFT "r1, r0"       is OP=0x97  {
        r1 = r1 << r0;
}
:RSHIFT "r1, r0"       is OP=0x98  {
        r1 =  r1 >> r0;
}
:CAST_FLOAT "r0"       is OP=0x9D  {
        r0 = int2float(r0);
}
:FADD   "r1, r0"     is OP=0xA3  {
        r1 = r0 f+ r1;
}
:FSUB   "r1, r0"     is OP=0xA4  {
        r1 = r0 f- r1;
}
:FMUL   "r1, r0"     is OP=0xA5  {
        r1 = r0 f* r1;
}
:FDIV   "r1, r0"     is OP=0xA6  {
        r1 = r0 f/ r1;
}

#########################################################################################################
# Incomplete
#########################################################################################################

#0x88 	        1000 1000 	==
#curr_stack->R1 = (curr_stack->R1 != curr_stack->R0) - 1;
:IS_EQU          is OP=0x88  unimpl

#0x89 	        1000 1001 	!=
:IS_NEQ          is OP=0x89  unimpl

#0x8A 	        1000 1010 	>=
:gt"/eq"         is OP=0x8A  unimpl

#0x8B 	        1000 1011 	>
:gt           is OP=0x8B  unimpl

#0x8C 	        1000 1100 	<=
:lt"/eq"         is OP=0x8C  unimpl

#0x8D 	        1000 1101 	<
:lt           is OP=0x8D  unimpl

#0x9E 	        1001 1110 	signed cast
:CAST_SIGN        is OP=0x9E  unimpl

#0x9F 	        1001 1111 	(float) <=
:flt"/eq"        is OP=0x9F  unimpl

#0xA0 	        1010 0000 	(float) <
:f"/lt"        is OP=0xA0  unimpl

#0xA1 	        1010 0001 	(float) >= (<= inverted)
:fgt"/eq"        is OP=0xA1  unimpl

#0xA2 	        1010 0010 	(float) > (< inverted)
:f"/gt"        is OP=0xA2  unimpl

#0x40 - 0x4F 	0100 xxxx 	Writes value from last time to stack