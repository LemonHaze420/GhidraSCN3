# Processor Configuration
define endian=little;
define alignment=1;

define space ram        type=ram_space          size=4 wordsize=1 default;
define space register   type=register_space     size=4;

define register offset=0x00 size=4 [ r0 r1 r2 r3 r14 sp ];

define token instr(8)
	OP = (0, 7);
define token immtoken1(8)
        imm8 = (0, 7);
define token immtoken2(16)
        imm16 = (0, 15);
define token immtoken4(32)
        imm32 = (0, 31);

# Macros 
        
imm8t:          "#"^imm8         is imm8         { tmp:4 = imm8; export tmp; }
imm16t:         "#"^imm16        is imm16        { tmp:4 = imm16; export tmp; }
imm32t:         "#"^imm32        is imm32        { tmp:4 = imm32; export tmp; }


# interesting snippet..
# The above is a contrived example of using the address-of operator to copy from a register that is not explicitly indicated by the instruction. This example constructs the address of the register following r1 within the register space, and then loads r1 with data from that address. The net effect of all this is that the register following r1 is copied into r1, even though it is not mentioned directly in the instruction. Notice that the address-of operator only produces the offset portion of the address, and to copy the desired value, the ‘*’ operator must have a register space override. 
# tmp:4 = &r1 + 4; r1 = *[register]tmp;

macro push(x){
	sp = sp - 4;
	*:4 sp = x;
}
macro pop(x){
	x = *:4 sp;
	sp = sp + 4;
}

# Instructions
define pcodeop MOBJ1;
define pcodeop MOBJ2;
define pcodeop MOBJ3;

:MOBJ1 imm8t             is OP=0x10 ; imm8t {
        MOBJ1(imm8t);
}
:MOBJ2 imm8t             is OP=0x11 ; imm8t {
        MOBJ2(imm8t);
}
:MOBJ3 imm8t             is OP=0x12 ; imm8t {
        MOBJ3(imm8t);
}
:MOBJ1 imm16t            is OP=0x20 ; imm16t {
        MOBJ1(imm16t);
}
:MOBJ2 imm16t            is OP=0x21 ; imm16t {
        MOBJ2(imm16t);
}
:MOBJ3 imm16t            is OP=0x22 ; imm16t {
        MOBJ3(imm16t);
}
:MOBJ1 imm32t            is OP=0x30 ; imm32t {
        MOBJ1(imm32t);
}
:MOBJ2 imm32t            is OP=0x31 ; imm32t {
        MOBJ2(imm32t);
}
:MOBJ3 imm32t            is OP=0x32 ; imm32t {
        MOBJ3(imm32t);
}

# PUSH
# @TODO: Clean these up, we can reduce how many we define by using bitmasks.

:PUSH imm8t             is OP=0x17 ; imm8t {
        r0 = imm8t;
}
:PUSH imm16t            is OP=0x27 ; imm16t {
        r0 = imm16t;
}
:PUSH imm32t            is OP=0x37 ; imm32t {
        r0 = imm32t;
}
:PUSH imm8t             is OP=0x50 ; imm8t {
        r0 = imm8t;
}
:PUSH imm8t             is OP=0x51 ; imm8t {
        r0 = imm8t;
}
:PUSH imm16t            is OP=0x52 ; imm16t {
        r0 = imm16t;
}
:PUSH imm32t            is OP=0x53 ; imm32t {
        r0 = imm32t;
}
:PUSH imm8t             is OP=0x5E ; imm8t {
        r0 = imm8t;
}
:PUSH imm16t             is OP=0x60 ; imm16t {
        r0 = imm16t;
}
:PUSH imm8t             is OP=0x61 ; imm8t {
        r0 = imm8t;
}
:PUSH imm16t            is OP=0x62 ; imm16t {
        r0 = imm16t;
}
:PUSH imm32t            is OP=0x63 ; imm32t {
        r0 = imm32t;
}
:PUSH imm32t             is OP=0x70 ; imm32t {
        r0 = imm32t;
}
:PUSH imm8t             is OP=0x71 ; imm8t {
        r0 = imm8t;
}
:PUSH imm16t            is OP=0x72 ; imm16t {
        r0 = imm16t;
}
:PUSH imm32t            is OP=0x73 ; imm32t {
        r0 = imm32t;        
}

# ADD SP, #X

:ADD "SP, " imm8t             is OP=0x13 ; imm8t {
        sp = sp + imm8t;
}
:ADD "SP, " imm16t            is OP=0x23 ; imm16t {
        sp = sp + imm16t;
}
:ADD "SP, " imm32t            is OP=0x33 ; imm32t {
        sp = sp + imm32t;
}

# JMP

# JMP by IMM + other val
:JMP imm8t             is OP=0x14 ; imm8t {
        local dest = imm8t + inst_next;
        goto [dest];
}
:JMP imm16t            is OP=0x24 ; imm16t {
        local dest = imm16t + inst_next;
        goto [dest];
}
:JMP imm32t            is OP=0x34 ; imm32t {
        local dest = imm32t + inst_next;
        goto [dest];
}

# JMP by IMM
:JMP imm8t             is OP=0x15 ; imm8t {
        local dest = imm8t + inst_next;
        goto [dest];
}
:JMP imm16t            is OP=0x25 ; imm16t {
        local dest = imm16t + inst_next;
        goto [dest];
}
:JMP imm32t            is OP=0x35 ; imm32t {
        local dest = imm32t + inst_next;
        goto [dest];
}

# IF R14 is zero, then JMP...
:JZ imm8t             is OP=0x16 ; imm8t {
        local dest = imm8t + inst_next;
        if ( r14 != 0 ) goto <skip>;
        goto [dest];
        <skip>
}
:JZ imm16t            is OP=0x26 ; imm16t {
        local dest = imm16t + inst_next;
        if ( r14 != 0 ) goto <skip>;
        goto [dest];
        <skip>
}
:JZ imm32t            is OP=0x36 ; imm32t {
        local dest = imm32t + inst_next;
        if ( r14 != 0 ) goto <skip>;
        goto [dest];
        <skip>
}

# CALL

:CALL imm8t             is OP=0x19 ; imm8t unimpl
:CALL imm16t            is OP=0x29 ; imm16t unimpl
:CALL imm32t            is OP=0x39 ; imm32t unimpl

:CALL imm8t             is OP=0x1A ; imm8t unimpl
:CALL imm16t            is OP=0x2A ; imm16t unimpl
:CALL imm32t            is OP=0x3A ; imm32t unimpl

define pcodeop ShenmueFunc;

# Shenmue Fn Table
:CALL_SSF imm8t             is OP=0x1B ; imm8t {
        ShenmueFunc(imm8t, r0, r1, r2, r3);
}
:CALL_SSF imm16t            is OP=0x2B ; imm16t {
        ShenmueFunc(imm16t, r0, r1, r2, r3);
}
:CALL_SSF imm32t            is OP=0x3B ; imm32t {
        ShenmueFunc(imm32t, r0, r1, r2, r3);
}

:CALL imm8t             is OP=0x1C ; imm8t unimpl
:CALL imm16t            is OP=0x2C ; imm16t unimpl
:CALL imm32t            is OP=0x3C ; imm32t unimpl

:CALL imm8t             is OP=0x1D ; imm8t unimpl
:CALL imm16t            is OP=0x2D ; imm16t unimpl
:CALL imm32t            is OP=0x3D ; imm32t unimpl


# Invalid Opcode
:RET            is OP=0x00 {
        tmp:4 = 0;
        return [tmp];
}

# Operators

#0x88 	        1000 1000 	==
:IS_EQU          is OP=0x88  unimpl
        #curr_stack->R1 = (curr_stack->R1 != curr_stack->R0) - 1;


#0x89 	        1000 1001 	!=
:IS_NEQ          is OP=0x89  unimpl

#0x8A 	        1000 1010 	>=
:IS_GTEQ         is OP=0x8A  unimpl

#0x8B 	        1000 1011 	>
:IS_GT           is OP=0x8B  unimpl

#0x8C 	        1000 1100 	<=
:IS_LTEQ         is OP=0x8C  unimpl

#0x8D 	        1000 1101 	<
:IS_LT           is OP=0x8D  unimpl

#0x8E 	        1000 1110 	~
:ONESCOMP           is OP=0x8E {
        r0 = ~r0;
}

#0x8F 	        1000 1111 	&=
:ANDEQ        is OP=0x8F  {
        r1 = r1 & r0;
}

#0x90 	        1001 0000 	=
:EQ         is OP=0x90  unimpl

#0x91 	        1001 0001 	^=
:XOR_EQ         is OP=0x91  {
        r1 = r1 ^ r0;
}

#0x92 	        1001 0010 	+=
:ADD_EQ          is OP=0x92  {
        r1 = r1 + r0;
}

#0x93 	        1001 0011 	-=
:SUB_EQ         is OP=0x93  {
        r1 = r1 - r0;
}

#0x94 	        1001 0100 	*=
:MUL_EQ         is OP=0x94  {
        r1 = r1 * r0;
}

#0x95 	        1001 0101 	/=
:DIV_EQ         is OP=0x95  {
        r1 = r1 / r0;
}

#0x96 	        1001 0110 	%=
:MOD_EQ         is OP=0x96  {
        r1 = r1 % r0;
}

#0x97 	        1001 0111 	<<=
:LSHIFT_EQ        is OP=0x97  {
        r1 = r1 << r0;
}

#0x98 	        1001 1000 	>>=
:RSHIFT_EQ        is OP=0x98  {
        r1 =  r1 >> r0;
}

#0x9D 	        1001 1101 	float cast
:CAST_FLOAT        is OP=0x9D  {
        r0 = int2float(r0);
}

#0x9E 	        1001 1110 	signed cast
:CAST_SIGN        is OP=0x9E  unimpl

#0x9F 	        1001 1111 	(float) <=
:flteq        is OP=0x9F  {
        #r1 = r0 <= r1 - 1;
}

#0xA0 	        1010 0000 	(float) <
:flt        is OP=0xA0  unimpl

#0xA1 	        1010 0001 	(float) >= (<= inverted)
:fgteq        is OP=0xA1  unimpl

#0xA2 	        1010 0010 	(float) > (< inverted)
:fgt        is OP=0xA2  unimpl

#0xA3 	        1010 0011 	(float) +
:fadd        is OP=0xA3  {
        r1 = r0 f+ r1;
}

#0xA4 	        1010 0100 	(float) -
:fsub        is OP=0xA4  {
        r1 = r0 f- r1;
}

#0xA5 	        1010 0101 	(float) *
:fmul        is OP=0xA5  {
        r1 = r0 f* r1;
}

#0xA6 	        1010 0110 	(float) / 
:fdiv        is OP=0xA6  {
        r1 = r0 f/ r1;
}

#0x80 	        1000 0000 	Write stack value to R14
:writeR14        is OP=0x80  unimpl

#0x81 	        1000 0001 	Read R14 value to stack
:readR14        is OP=0x81  unimpl


# Incomplete
#0x82 	        1000 0010 	[MOBJ] Reads 8-bit value from cycle pointer
#0x83 	        1000 0011 	[MOBJ] Reads 16-bit value from cycle pointer
#0x84 	        1000 0100 	[MOBJ] Reads 32-bit value from cycle pointer
#0x85 	        1000 0101 	[MOBJ] Writes 8-bit to cycle pointer
#0x86 	        1000 0110 	[MOBJ] Writes 16-bit to cycle pointer
#0x87 	        1000 0111 	[MOBJ] Writes 32-bit to cycle pointer
#0x40 - 0x4F 	0100 xxxx 	Writes value from last time to stack
