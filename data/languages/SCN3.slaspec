#########################################################################################################
# Scenario Script v3 VM processor module
# 
# 
#########################################################################################################
# Processor Configuration
#########################################################################################################
define endian=little;
define alignment=1;

define space ram        type=ram_space          size=4 wordsize=1 default;
define space register   type=register_space     size=4;

define register offset=0x00 size=4 [ r0 r1 r2 r3 r14 sp ];

define token instr(8)
	OP = (0, 7);
define token immtoken1(8)
        imm8 = (0, 7);
define token immtoken2(16)
        imm16 = (0, 15);
define token immtoken4(32)
        imm32 = (0, 31);

#########################################################################################################
# Macros 
#########################################################################################################    
imm8t:          "#"^imm8         is imm8         { tmp:4 = imm8; export tmp; }
imm16t:         "#"^imm16        is imm16        { tmp:4 = imm16; export tmp; }
imm32t:         "#"^imm32        is imm32        { tmp:4 = imm32; export tmp; }

macro push(x){
        local oldR2 = r2;
        r3 = oldR2;
        local oldR1 = r1;
        r2 = oldR1;
        local oldR0 = r0;
        r1 = oldR0;
        r0 = x;    
        
	#sp = sp - 4;
	#*:4 sp = x;  
}
macro pop(x){
	x = *:4 sp;
	sp = sp + 4;
}

#########################################################################################################
# Instructions
#########################################################################################################
define pcodeop MOBJ1;
define pcodeop MOBJ2;
define pcodeop MOBJ3;
define pcodeop ShenmueFunc;

:MOBJ1 imm8t             is OP=0x10 ; imm8t {
        MOBJ1(imm8t);
}
:MOBJ2 imm8t             is OP=0x11 ; imm8t {
        MOBJ2(imm8t);
}
:MOBJ3 imm8t             is OP=0x12 ; imm8t {
        MOBJ3(imm8t);
}
:MOBJ1 imm16t            is OP=0x20 ; imm16t {
        MOBJ1(imm16t);
}
:MOBJ2 imm16t            is OP=0x21 ; imm16t {
        MOBJ2(imm16t);
}
:MOBJ3 imm16t            is OP=0x22 ; imm16t {
        MOBJ3(imm16t);
}
:MOBJ1 imm32t            is OP=0x30 ; imm32t {
        MOBJ1(imm32t);
}
:MOBJ2 imm32t            is OP=0x31 ; imm32t {
        MOBJ2(imm32t);
}
:MOBJ3 imm32t            is OP=0x32 ; imm32t {
        MOBJ3(imm32t);
}

#########################################################################################################
# PUSH
#########################################################################################################
# @TODO: Clean these up, we can reduce how many we define by using bitmasks.


:PUSH imm8t             is OP=0x17 ; imm8t {
        #r0 = imm8t;
        local val = imm8t;
        push(val);
}
:PUSH imm16t            is OP=0x27 ; imm16t {
        #r0 = imm16t;
        local val = imm16t;
        push(val);        
}
:PUSH imm32t            is OP=0x37 ; imm32t {
        #r0 = imm32t;
        local val = imm32t;
        push(val);         
}
:PUSH imm8t             is OP=0x50 ; imm8t {
        local val = imm8t;
        push(val);
}
:PUSH imm8t             is OP=0x51 ; imm8t {
        #r0 = imm8t;
        local val = imm8t;
        push(val);
}
:PUSH imm16t            is OP=0x52 ; imm16t {
        local val = imm16t;
        push(val);
}
:PUSH imm32t            is OP=0x53 ; imm32t {
        #r0 = imm32t;
        local val = imm32t;
        push(val); 
}
:PUSH imm8t             is OP=0x5E ; imm8t {
        local val = imm8t;
        push(val);
}
:PUSH imm16t             is OP=0x60 ; imm16t {
        #r0 = imm16t;
        local val = imm16t;
        push(val); 
}
:PUSH imm8t             is OP=0x61 ; imm8t {
        local val = imm8t;
        push(val);
}
:PUSH imm16t            is OP=0x62 ; imm16t {
        #r0 = imm16t;
        local val = imm16t;
        push(val); 
}
:PUSH imm32t            is OP=0x63 ; imm32t {
        #r0 = imm32t;
        local val = imm32t;
        push(val); 
}
:PUSH imm32t             is OP=0x70 ; imm32t {
        #r0 = imm32t;
        local val = imm32t;
        push(val); 
}
:PUSH imm8t             is OP=0x71 ; imm8t {
        local val = imm8t;
        push(val);
}
:PUSH imm16t            is OP=0x72 ; imm16t {
        #r0 = imm16t;
        local val = imm16t;
        push(val); 
}
:PUSH imm32t            is OP=0x73 ; imm32t {
        #r0 = imm32t;
        local val = imm32t;
        push(val);      
}








#########################################################################################################
# ADD SP, #X
#########################################################################################################
:ADD "SP, " imm8t             is OP=0x13 ; imm8t {
        sp = sp + imm8t;
}
:ADD "SP, " imm16t            is OP=0x23 ; imm16t {
        sp = sp + imm16t;
}
:ADD "SP, " imm32t            is OP=0x33 ; imm32t {
        sp = sp + imm32t;
}

#########################################################################################################
# JMP
#########################################################################################################

# JMP by IMM + other val
:JMP imm8t             is OP=0x14 ; imm8t {
        local dest = imm8t + inst_next + 1;
        goto [dest];
}
:JMP imm16t            is OP=0x24 ; imm16t {
        local dest = imm16t + inst_next + 1;
        goto [dest];
}
:JMP imm32t            is OP=0x34 ; imm32t {
        local dest = imm32t + inst_next  +1;
        goto [dest];
}

# JMP by IMM
:JMP imm8t             is OP=0x15 ; imm8t {
        local dest = imm8t + inst_next +1;
        goto [dest];
}
:JMP imm16t            is OP=0x25 ; imm16t {
        local dest = imm16t + inst_next +1;
        goto [dest];
}
:JMP imm32t            is OP=0x35 ; imm32t {
        local dest = imm32t + inst_next;
        goto [dest];
}

# IF R14 is zero, then JMP...
:JZ imm8t             is OP=0x16 ; imm8t {
        local dest = imm8t + inst_next +1;
        if ( r14 != 0 ) goto <skip>;
        goto [dest];
        <skip>
}
:JZ imm16t            is OP=0x26 ; imm16t {
        local dest = imm16t + inst_next +1;
        if ( r14 != 0 ) goto <skip>;
        goto [dest];
        <skip>
}
:JZ imm32t            is OP=0x36 ; imm32t {
        local dest = imm32t + inst_next +1;
        if ( r14 != 0 ) goto <skip>;
        goto [dest];
        <skip>
}

#########################################################################################################
# CALL
#########################################################################################################

:CALL imm8t             is OP=0x19 ; imm8t unimpl
:CALL imm16t            is OP=0x29 ; imm16t unimpl
:CALL imm32t            is OP=0x39 ; imm32t unimpl

:CALL imm8t             is OP=0x1A ; imm8t unimpl
:CALL imm16t            is OP=0x2A ; imm16t unimpl
:CALL imm32t            is OP=0x3A ; imm32t unimpl

# Shenmue Fn Table
:CALL_SSF imm8t             is OP=0x1B ; imm8t {

        # tmp:4 = &r1 + 4; 
        # r1 = *[register]tmp;
        
        # The above is a contrived example of using the address-of operator to copy from a register that is not explicitly indicated by the instruction. 
        # This example constructs the address of the register following r1 within the register space, and then loads r1 with data from that address. 
        # The net effect of all this is that the register following r1 is copied into r1, even though it is not mentioned directly in the instruction. 
        # Notice that the address-of operator only produces the offset portion of the address, and to copy the desired value, the ‘*’ operator must have a register space override. 

        ShenmueFunc(imm8t, sp);
        # ShenmueFunc(imm8t, r0, r1, r2, r3);
}
:CALL_SSF imm16t            is OP=0x2B ; imm16t {
        ShenmueFunc(imm16t, sp);
        # ShenmueFunc(imm16t, r0, r1, r2, r3);
}
:CALL_SSF imm32t            is OP=0x3B ; imm32t {
        ShenmueFunc(imm32t, sp);
        # ShenmueFunc(imm32t, r0, r1, r2, r3);
}

:CALL imm8t             is OP=0x1C ; imm8t unimpl
:CALL imm16t            is OP=0x2C ; imm16t unimpl
:CALL imm32t            is OP=0x3C ; imm32t unimpl

:CALL imm8t             is OP=0x1D ; imm8t unimpl
:CALL imm16t            is OP=0x2D ; imm16t unimpl
:CALL imm32t            is OP=0x3D ; imm32t unimpl


# Invalid Opcode
:RET            is OP=0x00 {
        tmp:4 = 0;
        return [tmp];
}

#########################################################################################################
# Operators
#########################################################################################################

:NEG           is OP=0x8E {
        r0 = ~r0;
}
:AND        is OP=0x8F  {
        r1 = r1 & r0;
}
:OR         is OP=0x90  {
        r1 = r1 | r0;
}
:XOR         is OP=0x91  {
        r1 = r1 ^ r0;
}
:ADD          is OP=0x92  {
        r1 = r1 + r0;
}
:SUB         is OP=0x93  {
        r1 = r1 - r0;
}
:MUL         is OP=0x94  {
        r1 = r1 * r0;
}
:DIV         is OP=0x95  {
        r1 = r1 / r0;
}
:MOD         is OP=0x96  {
        r1 = r1 % r0;
}
:LSHIFT        is OP=0x97  {
        r1 = r1 << r0;
}
:RSHIFT        is OP=0x98  {
        r1 =  r1 >> r0;
}
:CAST_FLOAT        is OP=0x9D  {
        r0 = int2float(r0);
}
:FADD        is OP=0xA3  {
        r1 = r0 f+ r1;
}
:FSUB        is OP=0xA4  {
        r1 = r0 f- r1;
}
:FMUL        is OP=0xA5  {
        r1 = r0 f* r1;
}
:FDIV        is OP=0xA6  {
        r1 = r0 f/ r1;
}

#########################################################################################################
# Incomplete
#########################################################################################################

#0x80 	        1000 0000 	Write stack value to R14
:writeR14        is OP=0x80  unimpl

#0x81 	        1000 0001 	Read R14 value to stack
:readR14        is OP=0x81  unimpl

#0x88 	        1000 1000 	==
#curr_stack->R1 = (curr_stack->R1 != curr_stack->R0) - 1;
:IS_EQU          is OP=0x88  unimpl

#0x89 	        1000 1001 	!=
:IS_NEQ          is OP=0x89  unimpl

#0x8A 	        1000 1010 	>=
:gt"/eq"         is OP=0x8A  unimpl

#0x8B 	        1000 1011 	>
:gt           is OP=0x8B  unimpl

#0x8C 	        1000 1100 	<=
:lt"/eq"         is OP=0x8C  unimpl

#0x8D 	        1000 1101 	<
:lt           is OP=0x8D  unimpl

#0x9E 	        1001 1110 	signed cast
:CAST_SIGN        is OP=0x9E  unimpl

#0x9F 	        1001 1111 	(float) <=
:flt"/eq"        is OP=0x9F  unimpl

#0xA0 	        1010 0000 	(float) <
:f"/lt"        is OP=0xA0  unimpl

#0xA1 	        1010 0001 	(float) >= (<= inverted)
:fgt"/eq"        is OP=0xA1  unimpl

#0xA2 	        1010 0010 	(float) > (< inverted)
:f"/gt"        is OP=0xA2  unimpl

#0x82 	        1000 0010 	[MOBJ] Reads 8-bit value from cycle pointer
:RD8CYCL        is OP=0x82  unimpl

#0x83 	        1000 0011 	[MOBJ] Reads 16-bit value from cycle pointer
:RD16CYCL        is OP=0x83  unimpl

#0x84 	        1000 0100 	[MOBJ] Reads 32-bit value from cycle pointer
:RD32CYCL        is OP=0x84  unimpl

#0x85 	        1000 0101 	[MOBJ] Writes 8-bit to cycle pointer
:WR8CYCL         is OP=0x85  unimpl

#0x86 	        1000 0110 	[MOBJ] Writes 16-bit to cycle pointer
:WR16CYCL        is OP=0x86  unimpl

#0x87 	        1000 0111 	[MOBJ] Writes 32-bit to cycle pointer
:WR32CYCL        is OP=0x87  unimpl




#0x40 - 0x4F 	0100 xxxx 	Writes value from last time to stack